<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Mini Block Blast (HTML)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --grid:#0f1730;
      --line:#2a3766;
      --text:#eaf0ff;
      --muted:#a9b6e6;

      --cell: min(8.5vw, 38px);
      --gap: 2px;
      --radius: 14px;
      --accent:#7aa7ff;
      --bad:#ff6a6a;
      --good:#63f5b6;

      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 700px at 50% -10%, #1a2a66 0%, var(--bg) 55%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding: 14px 10px 22px;
    }

    .app{
      width: min(520px, 100%);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 12px 14px;
      background: rgba(17,26,51,.7);
      border:1px solid rgba(122,167,255,.18);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
    }

    .title{
      display:flex;
      flex-direction:column;
      line-height:1.1;
    }
    .title b{ font-size: 14px; letter-spacing:.2px;}
    .title span{ font-size: 12px; color:var(--muted); }

    .stats{
      display:flex;
      align-items:center;
      gap:10px;
      font-size: 13px;
      color:var(--muted);
      white-space:nowrap;
    }
    .stats .pill{
      padding:6px 10px;
      border-radius: 999px;
      background: rgba(15,23,48,.8);
      border:1px solid rgba(122,167,255,.18);
      color: var(--text);
    }
    button{
      border:0;
      background: rgba(122,167,255,.14);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      border:1px solid rgba(122,167,255,.25);
      font-weight:600;
    }
    button:active{ transform: translateY(1px); }

    .boardWrap{
      padding: 14px;
      background: rgba(17,26,51,.55);
      border:1px solid rgba(122,167,255,.18);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .board{
      display:grid;
      grid-template-columns: repeat(10, var(--cell));
      grid-template-rows: repeat(10, var(--cell));
      gap: var(--gap);
      justify-content:center;
      touch-action: manipulation;
      user-select:none;
      background: rgba(15,23,48,.55);
      padding: 10px;
      border-radius: 16px;
      border:1px solid rgba(122,167,255,.12);
    }

    .cell{
      width: var(--cell);
      height: var(--cell);
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(42,55,102,.5);
      border-radius: 7px;
      position:relative;
      overflow:hidden;
    }
    .cell.filled{
      border-color: rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
    }
    .cell.filled::after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(80% 80% at 30% 20%, rgba(255,255,255,.16), rgba(0,0,0,0) 55%);
    }

    .cell.preview-ok{
      outline: 2px solid rgba(99,245,182,.55);
      outline-offset: -2px;
    }
    .cell.preview-bad{
      outline: 2px solid rgba(255,106,106,.55);
      outline-offset: -2px;
    }

    .tray{
      padding: 14px;
      background: rgba(17,26,51,.55);
      border:1px solid rgba(122,167,255,.18);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height:1.35;
    }

    .pieces{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
    }

    .pieceBtn{
      background: rgba(15,23,48,.8);
      border:1px solid rgba(122,167,255,.18);
      border-radius: 14px;
      padding: 10px 8px;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height: 92px;
      position:relative;
    }
    .pieceBtn.selected{
      border-color: rgba(122,167,255,.65);
      box-shadow: 0 0 0 3px rgba(122,167,255,.18);
    }
    .miniGrid{
      display:grid;
      gap:3px;
      grid-template-columns: repeat(5, 14px);
      grid-template-rows: repeat(5, 14px);
      transform: translateZ(0);
    }
    .miniCell{
      width:14px;height:14px;
      border-radius:4px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(42,55,102,.5);
    }
    .miniCell.on{
      background: rgba(122,167,255,.38);
      border-color: rgba(122,167,255,.4);
    }

    .toast{
      position:fixed;
      left:50%;
      bottom: 14px;
      transform: translateX(-50%);
      background: rgba(17,26,51,.92);
      border:1px solid rgba(122,167,255,.25);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 13px;
      color: var(--text);
      box-shadow: var(--shadow);
      max-width: min(520px, calc(100% - 20px));
      text-align:center;
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease;
    }
    .toast.show{ opacity:1; }

    .modal{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
      background: rgba(0,0,0,.5);
    }
    .modal.show{ display:flex; }
    .card{
      width: min(520px, 100%);
      background: rgba(17,26,51,.96);
      border:1px solid rgba(122,167,255,.25);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .card h2{ margin: 2px 0 8px; font-size: 18px; }
    .card p{ margin: 0 0 12px; color: var(--muted); font-size: 13px; line-height:1.4; }
    .row{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        <b>Mini Block Blast</b>
        <span>Érintés: alakzat → tábla cella</span>
      </div>
      <div class="stats">
        <div class="pill">Pont: <span id="score">0</span></div>
        <button id="newBtn" type="button">Új játék</button>
      </div>
    </header>

    <div class="boardWrap">
      <div id="board" class="board" aria-label="Játéktábla"></div>
    </div>

    <div class="tray">
      <div class="hint">
        Válassz egy alakzatot lent, majd bökj a táblán egy cellára. Ha elfér, lerakja.
        Ha egy sor vagy oszlop megtelik, törlődik és pontot kapsz. [web:6]
      </div>
      <div id="pieces" class="pieces"></div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Vége a játéknak</h2>
      <p id="finalText"></p>
      <div class="row">
        <button id="againBtn" type="button">Újra</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const N = 10;

  // 5x5-ös sablonok (1 = kitöltött).
  const SHAPES = [
    // 1
    [[1]],
    // 2
    [[1,1]],
    [[1],[1]],
    // 3
    [[1,1,1]],
    [[1],[1],[1]],
    [[1,1],[1,0]],
    [[1,1],[0,1]],
    [[1,0],[1,1]],
    [[0,1],[1,1]],
    // 4
    [[1,1,1,1]],
    [[1],[1],[1],[1]],
    [[1,1],[1,1]],
    [[1,1,1],[1,0,0]],
    [[1,1,1],[0,0,1]],
    [[1,0,0],[1,1,1]],
    [[0,0,1],[1,1,1]],
    // 5
    [[1,1,1,1,1]],
    [[1],[1],[1],[1],[1]],
    [[1,1,1],[0,1,0]]
  ];

  // ---- State
  let grid = Array.from({length:N}, () => Array(N).fill(0));
  let score = 0;
  let selectedPieceIndex = -1; // 0..2
  let pieces = []; // {shape, used:false}

  // ---- DOM
  const boardEl = document.getElementById('board');
  const piecesEl = document.getElementById('pieces');
  const scoreEl = document.getElementById('score');
  const toastEl = document.getElementById('toast');
  const modalEl = document.getElementById('modal');
  const finalTextEl = document.getElementById('finalText');

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(() => toastEl.classList.remove('show'), 1400);
  }

  function clone2D(a){ return a.map(r => r.slice()); }

  function randomShape(){
    const s = SHAPES[Math.floor(Math.random()*SHAPES.length)];
    return clone2D(s);
  }

  function normalizeShape(shape){
    // bal-felsőre igazítás (ha lenne üres sor/oszlop)
    // (most minden sablon már ilyen, de maradjon stabil)
    let top = 0;
    while(top < shape.length && shape[top].every(v => v===0)) top++;
    let left = 0;
    while(true){
      let allZero = true;
      for(let r=0;r<shape.length;r++){
        if(shape[r][left] === 1){ allZero = false; break; }
      }
      if(!allZero) break;
      left++;
      if(left >= shape[0].length) break;
    }
    const cropped = [];
    for(let r=top;r<shape.length;r++){
      const row = shape[r].slice(left);
      if(row.some(v=>v===1)) cropped.push(row);
    }
    return cropped.length ? cropped : [[1]];
  }

  function newPieces(){
    pieces = Array.from({length:3}, () => ({ shape: normalizeShape(randomShape()), used:false }));
    selectedPieceIndex = -1;
    renderPieces();
  }

  function renderBoard(){
    boardEl.innerHTML = '';
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const d = document.createElement('div');
        d.className = 'cell' + (grid[r][c] ? ' filled' : '');
        d.dataset.r = r;
        d.dataset.c = c;
        boardEl.appendChild(d);
      }
    }
  }

  function shapeCells(shape){
    const cells = [];
    for(let r=0;r<shape.length;r++){
      for(let c=0;c<shape[r].length;c++){
        if(shape[r][c]) cells.push([r,c]);
      }
    }
    return cells;
  }

  function canPlace(shape, baseR, baseC){
    const cells = shapeCells(shape);
    for(const [dr,dc] of cells){
      const r = baseR + dr;
      const c = baseC + dc;
      if(r < 0 || r >= N || c < 0 || c >= N) return false;
      if(grid[r][c]) return false;
    }
    return true;
  }

  function place(shape, baseR, baseC){
    const cells = shapeCells(shape);
    for(const [dr,dc] of cells){
      grid[baseR+dr][baseC+dc] = 1;
    }
    score += cells.length; // alap pont
    scoreEl.textContent = score;
  }

  function clearLines(){
    const fullRows = [];
    const fullCols = [];

    for(let r=0;r<N;r++){
      if(grid[r].every(v=>v===1)) fullRows.push(r);
    }
    for(let c=0;c<N;c++){
      let ok = true;
      for(let r=0;r<N;r++){
        if(!grid[r][c]) { ok=false; break; }
      }
      if(ok) fullCols.push(c);
    }

    if(!fullRows.length && !fullCols.length) return 0;

    // törlés
    for(const r of fullRows){
      for(let c=0;c<N;c++) grid[r][c] = 0;
    }
    for(const c of fullCols){
      for(let r=0;r<N;r++) grid[r][c] = 0;
    }

    const cleared = fullRows.length * N + fullCols.length * N;
    // bónusz pont
    const bonus = (fullRows.length + fullCols.length) * 10;
    score += bonus;
    scoreEl.textContent = score;

    return bonus;
  }

  function anyMoveAvailable(){
    const remaining = pieces.filter(p => !p.used);
    if(!remaining.length) return true; // mind lerakva: jön az új hármas
    for(const p of remaining){
      for(let r=0;r<N;r++){
        for(let c=0;c<N;c++){
          if(canPlace(p.shape, r, c)) return true;
        }
      }
    }
    return false;
  }

  function renderPieces(){
    piecesEl.innerHTML = '';
    pieces.forEach((p, idx) => {
      const btn = document.createElement('div');
      btn.className = 'pieceBtn' + (idx===selectedPieceIndex ? ' selected' : '');
      btn.role = 'button';
      btn.tabIndex = 0;

      if(p.used){
        btn.style.opacity = '0.35';
      }

      const mini = document.createElement('div');
      mini.className = 'miniGrid';

      // 5x5 preview
      const shape = p.shape;
      const h = shape.length;
      const w = shape[0].length;

      // középre igazítás 5x5-ben
      const offR = Math.floor((5 - h)/2);
      const offC = Math.floor((5 - w)/2);

      for(let r=0;r<5;r++){
        for(let c=0;c<5;c++){
          const mc = document.createElement('div');
          mc.className = 'miniCell';
          const sr = r - offR;
          const sc = c - offC;
          if(sr>=0 && sr<h && sc>=0 && sc<w && shape[sr][sc]===1){
            mc.classList.add('on');
          }
          mini.appendChild(mc);
        }
      }

      btn.appendChild(mini);

      const pick = () => {
        if(p.used) { toast('Ezt már leraktad.'); return; }
        selectedPieceIndex = (selectedPieceIndex === idx) ? -1 : idx;
        renderPieces();
        clearPreview();
        if(selectedPieceIndex !== -1) toast('Most bökj a táblára egy cellára.');
      };

      btn.addEventListener('click', pick);
      btn.addEventListener('keydown', (e) => {
        if(e.key === 'Enter' || e.key === ' ') pick();
      });

      piecesEl.appendChild(btn);
    });
  }

  function clearPreview(){
    boardEl.querySelectorAll('.cell').forEach(el => {
      el.classList.remove('preview-ok','preview-bad');
    });
  }

  function previewAt(r, c){
    clearPreview();
    if(selectedPieceIndex === -1) return;
    const p = pieces[selectedPieceIndex];
    if(!p || p.used) return;

    const ok = canPlace(p.shape, r, c);
    const cls = ok ? 'preview-ok' : 'preview-bad';
    for(const [dr,dc] of shapeCells(p.shape)){
      const rr = r+dr, cc = c+dc;
      const el = boardEl.querySelector(`.cell[data-r="${rr}"][data-c="${cc}"]`);
      if(el) el.classList.add(cls);
    }
  }

  function onBoardTap(r, c){
    if(selectedPieceIndex === -1){
      toast('Előbb válassz egy alakzatot lent.');
      return;
    }
    const p = pieces[selectedPieceIndex];
    if(!p || p.used) return;

    if(!canPlace(p.shape, r, c)){
      toast('Ide nem fér.');
      return;
    }

    place(p.shape, r, c);
    p.used = true;
    selectedPieceIndex = -1;

    const bonus = clearLines();
    renderBoard();
    renderPieces();
    clearPreview();

    if(bonus) toast('Sor/oszlop törölve! +' + bonus);

    // mind a 3 lerakva -> új hármas
    if(pieces.every(x => x.used)){
      newPieces();
      toast('Új alakzatok!');
    }

    if(!anyMoveAvailable()){
      showGameOver();
    }
  }

  function showGameOver(){
    finalTextEl.textContent = `Pontszám: ${score}. Nincs több lehetséges lépés.`;
    modalEl.classList.add('show');
  }

  function hideGameOver(){
    modalEl.classList.remove('show');
  }

  function reset(){
    grid = Array.from({length:N}, () => Array(N).fill(0));
    score = 0;
    scoreEl.textContent = score;
    hideGameOver();
    renderBoard();
    newPieces();
    toast('Jó játékot!');
  }

  // Board events (mobil: érintésre is jó)
  boardEl.addEventListener('click', (e) => {
    const cell = e.target.closest('.cell');
    if(!cell) return;
    onBoardTap(+cell.dataset.r, +cell.dataset.c);
  });

  boardEl.addEventListener('pointermove', (e) => {
    // ujj alatt hover-szerű preview (nem minden böngészőn tökéletes, de hasznos)
    const target = document.elementFromPoint(e.clientX, e.clientY);
    const cell = target && target.closest ? target.closest('.cell') : null;
    if(!cell) return;
    previewAt(+cell.dataset.r, +cell.dataset.c);
  });

  document.getElementById('newBtn').addEventListener('click', reset);
  document.getElementById('againBtn').addEventListener('click', reset);
  modalEl.addEventListener('click', (e) => { if(e.target === modalEl) reset(); });

  // start
  renderBoard();
  newPieces();
})();
</script>
</body>
</html>
