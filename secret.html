<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Mini Block Blast – Drag (No Ghost)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --grid:#0f1730;
      --line:#2a3766;
      --text:#eaf0ff;
      --muted:#a9b6e6;

      --cell: min(8.5vw, 38px);
      --gap: 2px;
      --radius: 14px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 700px at 50% -10%, #1a2a66 0%, var(--bg) 55%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      justify-content:center;
      padding: 14px 10px 22px;
    }

    .app{ width: min(520px, 100%); display:flex; flex-direction:column; gap:12px; }

    header{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding: 12px 14px;
      background: rgba(17,26,51,.7);
      border:1px solid rgba(122,167,255,.18);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
    }

    .title{ display:flex; flex-direction:column; line-height:1.1; }
    .title b{ font-size: 14px; letter-spacing:.2px;}
    .title span{ font-size: 12px; color:var(--muted); }

    .stats{ display:flex; align-items:center; gap:10px; font-size: 13px; color:var(--muted); white-space:nowrap; }
    .stats .pill{
      padding:6px 10px; border-radius: 999px;
      background: rgba(15,23,48,.8);
      border:1px solid rgba(122,167,255,.18);
      color: var(--text);
    }

    button{
      border:0;
      background: rgba(122,167,255,.14);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      border:1px solid rgba(122,167,255,.25);
      font-weight:600;
    }
    button:active{ transform: translateY(1px); }

    .boardWrap{
      padding: 14px;
      background: rgba(17,26,51,.55);
      border:1px solid rgba(122,167,255,.18);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .board{
      display:grid;
      grid-template-columns: repeat(10, var(--cell));
      grid-template-rows: repeat(10, var(--cell));
      gap: var(--gap);
      justify-content:center;
      user-select:none;
      background: rgba(15,23,48,.55);
      padding: 10px;
      border-radius: 16px;
      border:1px solid rgba(122,167,255,.12);
    }

    .cell{
      width: var(--cell);
      height: var(--cell);
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(42,55,102,.5);
      border-radius: 7px;
      position:relative;
      overflow:hidden;
    }
    .cell.filled{
      border-color: rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
    }
    .cell.filled::after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(80% 80% at 30% 20%, rgba(255,255,255,.16), rgba(0,0,0,0) 55%);
    }

    .cell.preview-ok{ outline: 2px solid rgba(99,245,182,.55); outline-offset: -2px; }
    .cell.preview-bad{ outline: 2px solid rgba(255,106,106,.55); outline-offset: -2px; }

    .tray{
      padding: 14px;
      background: rgba(17,26,51,.55);
      border:1px solid rgba(122,167,255,.18);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .hint{ font-size: 12px; color: var(--muted); line-height:1.35; }

    .pieces{ display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; }

    .pieceBtn{
      background: rgba(15,23,48,.8);
      border:1px solid rgba(122,167,255,.18);
      border-radius: 14px;
      padding: 10px 8px;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height: 92px;
      position:relative;
      touch-action: none; /* ne scrollozzon/zoomoljon drag közben [web:46] */
      user-select:none;
    }
    .pieceBtn:active{ transform: translateY(1px); }

    .miniGrid{
      display:grid;
      gap:3px;
      grid-template-columns: repeat(5, 14px);
      grid-template-rows: repeat(5, 14px);
    }
    .miniCell{
      width:14px;height:14px;
      border-radius:4px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(42,55,102,.5);
    }
    .miniCell.on{
      background: rgba(122,167,255,.38);
      border-color: rgba(122,167,255,.4);
    }

    .toast{
      position:fixed;
      left:50%;
      bottom: 14px;
      transform: translateX(-50%);
      background: rgba(17,26,51,.92);
      border:1px solid rgba(122,167,255,.25);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 13px;
      color: var(--text);
      box-shadow: var(--shadow);
      max-width: min(520px, calc(100% - 20px));
      text-align:center;
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease;
    }
    .toast.show{ opacity:1; }

    .modal{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
      background: rgba(0,0,0,.5);
    }
    .modal.show{ display:flex; }
    .card{
      width: min(520px, 100%);
      background: rgba(17,26,51,.96);
      border:1px solid rgba(122,167,255,.25);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .card h2{ margin: 2px 0 8px; font-size: 18px; }
    .card p{ margin: 0 0 12px; color: var(--muted); font-size: 13px; line-height:1.4; }
    .row{ display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        <b>Mini Block Blast (Drag)</b>
        <span>Húzd az alakzatot a táblára (nincs ghost)</span>
      </div>
      <div class="stats">
        <div class="pill">Pont: <span id="score">0</span></div>
        <button id="newBtn" type="button">Új játék</button>
      </div>
    </header>

    <div class="boardWrap">
      <div id="board" class="board" aria-label="Játéktábla"></div>
    </div>

    <div class="tray">
      <div class="hint">
        Húzás közben a tábla jelzi (zöld/piros), hogy letehető-e, így nem takar ki semmi. [web:30]
      </div>
      <div id="pieces" class="pieces"></div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <div id="modal" class="modal" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Vége a játéknak</h2>
      <p id="finalText"></p>
      <div class="row">
        <button id="againBtn" type="button">Újra</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const N = 10;

  const SHAPES = [
    [[1]],
    [[1,1]], [[1],[1]],
    [[1,1,1]], [[1],[1],[1]],
    [[1,1],[1,0]], [[1,1],[0,1]], [[1,0],[1,1]], [[0,1],[1,1]],
    [[1,1,1,1]], [[1],[1],[1],[1]],
    [[1,1],[1,1]],
    [[1,1,1],[1,0,0]], [[1,1,1],[0,0,1]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]],
    [[1,1,1,1,1]], [[1],[1],[1],[1],[1]],
    [[1,1,1],[0,1,0]]
  ];

  let grid = Array.from({length:N}, () => Array(N).fill(0));
  let score = 0;
  let pieces = []; // {shape, used:false}

  const boardEl = document.getElementById('board');
  const piecesEl = document.getElementById('pieces');
  const scoreEl = document.getElementById('score');
  const toastEl = document.getElementById('toast');
  const modalEl = document.getElementById('modal');
  const finalTextEl = document.getElementById('finalText');

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(() => toastEl.classList.remove('show'), 1200);
  }

  function clone2D(a){ return a.map(r => r.slice()); }
  function randomShape(){ return clone2D(SHAPES[Math.floor(Math.random()*SHAPES.length)]); }

  function normalizeShape(shape){
    // biztos bal-felsőre igazítva
    let top = 0;
    while(top < shape.length && shape[top].every(v => v===0)) top++;
    let left = 0;
    while(left < shape[0].length){
      let allZero = true;
      for(let r=0;r<shape.length;r++){
        if(shape[r][left] === 1){ allZero = false; break; }
      }
      if(!allZero) break;
      left++;
    }
    const cropped = [];
    for(let r=top;r<shape.length;r++){
      const row = shape[r].slice(left);
      if(row.some(v=>v===1)) cropped.push(row);
    }
    return cropped.length ? cropped : [[1]];
  }

  function shapeCells(shape){
    const cells = [];
    for(let r=0;r<shape.length;r++){
      for(let c=0;c<shape[r].length;c++){
        if(shape[r][c]) cells.push([r,c]);
      }
    }
    return cells;
  }

  function canPlace(shape, baseR, baseC){
    for(const [dr,dc] of shapeCells(shape)){
      const r = baseR + dr, c = baseC + dc;
      if(r < 0 || r >= N || c < 0 || c >= N) return false;
      if(grid[r][c]) return false;
    }
    return true;
  }

  function place(shape, baseR, baseC){
    const cells = shapeCells(shape);
    for(const [dr,dc] of cells){
      grid[baseR+dr][baseC+dc] = 1;
    }
    score += cells.length;
    scoreEl.textContent = score;
  }

  function clearLines(){
    const fullRows = [];
    const fullCols = [];

    for(let r=0;r<N;r++){
      if(grid[r].every(v=>v===1)) fullRows.push(r);
    }
    for(let c=0;c<N;c++){
      let ok = true;
      for(let r=0;r<N;r++){
        if(!grid[r][c]) { ok=false; break; }
      }
      if(ok) fullCols.push(c);
    }

    if(!fullRows.length && !fullCols.length) return 0;

    for(const r of fullRows) for(let c=0;c<N;c++) grid[r][c] = 0;
    for(const c of fullCols) for(let r=0;r<N;r++) grid[r][c] = 0;

    const bonus = (fullRows.length + fullCols.length) * 10;
    score += bonus;
    scoreEl.textContent = score;
    return bonus;
  }

  function anyMoveAvailable(){
    const remaining = pieces.filter(p => !p.used);
    if(!remaining.length) return true;
    for(const p of remaining){
      for(let r=0;r<N;r++){
        for(let c=0;c<N;c++){
          if(canPlace(p.shape, r, c)) return true;
        }
      }
    }
    return false;
  }

  function renderBoard(){
    boardEl.innerHTML = '';
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const d = document.createElement('div');
        d.className = 'cell' + (grid[r][c] ? ' filled' : '');
        d.dataset.r = r;
        d.dataset.c = c;
        boardEl.appendChild(d);
      }
    }
  }

  function clearPreview(){
    boardEl.querySelectorAll('.cell').forEach(el => {
      el.classList.remove('preview-ok','preview-bad');
    });
  }

  function previewAt(r, c, shape){
    clearPreview();
    const ok = canPlace(shape, r, c);
    const cls = ok ? 'preview-ok' : 'preview-bad';
    for(const [dr,dc] of shapeCells(shape)){
      const rr = r+dr, cc = c+dc;
      const el = boardEl.querySelector(`.cell[data-r="${rr}"][data-c="${cc}"]`);
      if(el) el.classList.add(cls);
    }
    return ok;
  }

  function newPieces(){
    pieces = Array.from({length:3}, () => ({ shape: normalizeShape(randomShape()), used:false }));
    renderPieces();
  }

  function boardCellFromPoint(x, y){
    const el = document.elementFromPoint(x, y);
    const cell = el && el.closest ? el.closest('.cell') : null;
    if(!cell) return null;
    return { r:+cell.dataset.r, c:+cell.dataset.c };
  }

  // drag state
  let dragActive = false;
  let dragPieceIndex = -1;
  let dragPointerId = null;

  function renderPieces(){
    piecesEl.innerHTML = '';
    pieces.forEach((p, idx) => {
      const btn = document.createElement('div');
      btn.className = 'pieceBtn';
      btn.role = 'button';
      btn.tabIndex = 0;

      if(p.used){
        btn.style.opacity = '0.35';
      }

      const mini = document.createElement('div');
      mini.className = 'miniGrid';

      const shape = p.shape;
      const h = shape.length, w = shape[0].length;
      const offR = Math.floor((5 - h)/2);
      const offC = Math.floor((5 - w)/2);

      for(let r=0;r<5;r++){
        for(let c=0;c<5;c++){
          const mc = document.createElement('div');
          mc.className = 'miniCell';
          const sr = r - offR, sc = c - offC;
          if(sr>=0 && sr<h && sc>=0 && sc<w && shape[sr][sc]===1) mc.classList.add('on');
          mini.appendChild(mc);
        }
      }
      btn.appendChild(mini);

      btn.addEventListener('pointerdown', (e) => {
        if(p.used) { toast('Ezt már leraktad.'); return; }

        dragActive = true;
        dragPieceIndex = idx;
        dragPointerId = e.pointerId;

        // a további pointer eventek is ide jöjjenek [web:30]
        btn.setPointerCapture(e.pointerId);

        const cell = boardCellFromPoint(e.clientX, e.clientY);
        if(cell) previewAt(cell.r, cell.c, p.shape);
        else clearPreview();

        e.preventDefault();
      });

      btn.addEventListener('pointermove', (e) => {
        if(!dragActive || e.pointerId !== dragPointerId) return;

        const piece = pieces[dragPieceIndex];
        const cell = boardCellFromPoint(e.clientX, e.clientY);

        if(cell && piece && !piece.used) previewAt(cell.r, cell.c, piece.shape);
        else clearPreview();

        e.preventDefault();
      });

      const endDrag = (e) => {
        if(!dragActive || e.pointerId !== dragPointerId) return;

        const piece = pieces[dragPieceIndex];

        dragActive = false;
        dragPieceIndex = -1;
        dragPointerId = null;

        const cell = boardCellFromPoint(e.clientX, e.clientY);
        if(!cell || !piece || piece.used){
          clearPreview();
          return;
        }

        if(!canPlace(piece.shape, cell.r, cell.c)){
          toast('Ide nem fér.');
          clearPreview();
          return;
        }

        place(piece.shape, cell.r, cell.c);
        piece.used = true;

        const bonus = clearLines();
        renderBoard();
        renderPieces();
        clearPreview();
        if(bonus) toast('Törlés! +' + bonus);

        if(pieces.every(x => x.used)){
          newPieces();
          toast('Új alakzatok!');
        }

        if(!anyMoveAvailable()){
          showGameOver();
        }

        e.preventDefault();
      };

      btn.addEventListener('pointerup', endDrag);
      btn.addEventListener('pointercancel', endDrag);

      piecesEl.appendChild(btn);
    });
  }

  function showGameOver(){
    finalTextEl.textContent = `Pontszám: ${score}. Nincs több lehetséges lépés.`;
    modalEl.classList.add('show');
  }
  function hideGameOver(){ modalEl.classList.remove('show'); }

  function reset(){
    grid = Array.from({length:N}, () => Array(N).fill(0));
    score = 0;
    scoreEl.textContent = score;
    hideGameOver();
    clearPreview();
    renderBoard();
    newPieces();
  }

  document.getElementById('newBtn').addEventListener('click', reset);
  document.getElementById('againBtn').addEventListener('click', reset);
  modalEl.addEventListener('click', (e) => { if(e.target === modalEl) reset(); });

  renderBoard();
  newPieces();
})();
</script>
</body>
</html>
